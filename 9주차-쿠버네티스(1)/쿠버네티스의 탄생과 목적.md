## 1. 컨테이너 기반 어플리케이션

### 1.1 컨테이너

 컨테이너는 어플리케이션을 패키징하여 실행하는 논리적인 공간을 가리킵니다. 
 각 컨테이너는 개별적인 커널을 갖지 않고 호스트의 커널이 할당하는 자원을 빌려 사용합니다.
 VM과 컨테이너의 개념이 다소 혼동될 수 있으나, 개별적으로 커널을 가지고 있는지 혹은 호스트의 커널을 빌려 명령을 수행하는지를 비교하시면 좀 더 명확하게 이해하실 수 있습니다.
 ![화면 캡처 2021-10-18 201601](https://user-images.githubusercontent.com/62214428/137720654-3eb4a6fb-7e2e-4297-bf77-595b8d6f082d.png)

### 1.1.1 오버헤드 감소

 우리가 보통 커널에서 명령을 처리하는 데에는 각종 리소스가 투입됩니다. 
 가령, 인간의 삶에 비유하자면 출근을 해서 하는 업무에 들어가는 에너지가 100이라고 할 때, 세면을 하고 옷을 입고 출근 지하철을 타는 등의 부가적인 에너지가 10이 든다고 가정해 봅시다.
 여기서 본 업무 외에 추가적으로 소요된 에너지 10을 **오버헤드(Overhead)** 라고 합니다. 
 일반적인 상황에서 코어 업무가 아닌 오버헤드성 리소스가 늘어나는 것은 바람직하지 않습니다. 
 처리속도 지연, 가용 메모리 누수 등의 이슈를 초래하기 때문이죠. 아무리 효율적인 아키텍처라도 오버헤드를 0으로 만들 수는 없습니다.
 다만 이를 최소화 하여 시스템의 부하를 줄일 수 있기 때문에 많은 사람들이 이를 고민합니다. 
 컨테이너를 활용하는 경우 어플리케이션이 개별 커널을 구동하지 않으므로 VM의 방식과 비교하여 오버헤드 규모를 줄여서 서비스를 운영할 수 있습니다.
 
 ### 1.1.2 개발 효율성 증대

개발(development)과 운영(production) 환경은 엄밀히 분리되어야 함과 동시에 모든 사항을 빠짐없이 반영하여야 합니다. 만약 이 두 환경이 유기적으로 연동되어 있지 않으면 개발 단계에서 테스트를 거치지 않은 소스가 반영 혹은 미반영 되어 장애를 야기할 수 있습니다. 이 두 환경을 동일 선상에 놓기 위해서는 OS를 비롯한 각종 세팅이 완전히 같아야 합니다. 실제로 상이한 개발/운영 환경의 리스크로 인해 장애가 발생하는 경우는 서비스의 규모를 막론하고 매우 빈번하게 발생합니다.

컨테이너는 환경변수 등으로 개발/운영 환경을 제어하며, 이외 대부분의 항목을 동일하게 구성할 수 있습니다. 즉, 환경의 차이로 인해 발생하는 장애 리스크를 줄일 수 있는 것이죠. 물론 API 및 DBMS의 연동은 개발과 운영이 혼재되지 않도록 잘 관리해야 합니다.

## 1.2 Kubernetes와 컨테이너

쿠버네티스는 한마디로 **컨테이너를 효율적으로 관리할 수 있도록 도와주는 툴** 입니다. 그렇다면 우리는 컨테이너와 쿠버네티스의 관계성에 대해 파악해보아야 합니다. 공부를 하다보면 도커와 쿠버네티스는 어떻게 구분되는지, 그리고 기타 컨테이너 런타임은 도대체 어떻게 적용되는 것인지 혼동이 됩니다. 

하나의 서비스를 운영하는 데에는 수많은 컨테이너가 필요합니다. 장애를 예방하기 위해서는 동일한 서비스를 하는 컨테이너를 복수로 생성해놓기도 하죠. 다수의 컨테이너를 사람이 일일히 제어하는 것은 굉장히 쉽지 않은 일입니다. 구글은 대규모 컨테이너 기반 클러스터를 관리하기 위해 Borg(Kubernetes의 전신)라는 시스템을 개발, 도입하게 됩니다. 이를 기반으로 구글 클라우드의 엔지니어들이 Go 언어를 사용해 개발된 오픈소스 프로젝트가 바로 쿠버네티스 입니다.

쿠버네티스 아키텍처에서는 컨테이너를 그룹화하여 pod(파드) 라고 부릅니다. 이 파드는 하나 혹은 여러 개의 컨테이너로 구성되어 있으며, 개수에 상관없이 마치 하나처럼 취급됩니다. Deployment(디플로이먼트)는 버전 등을 포함한 컨테이너의 설정을 반영하는 기능을 하며, 쿠버네티스에서는 디플로이먼트를 기반으로 클러스터에 파드를 생성하고 정의된 상태를 유지합니다. 디플로이먼트에서 다뤄지는 여러 설정 중 중요한 것을 이르자면 주저없이 Replica(레플리카)를 꼽을 수 있습니다. 이는 일종의 복사본의 개념으로 동일한 내용의 컨테이너를 총 몇 개 생성할 지를 결정합니다.

Service(서비스) 라는 이름의 설정 파일은 어떤 컨테이너로 외부에서 인입되는 트래픽을 유도하는 지를 결정하는 로드 밸런서를 생성하는 데에 사용됩니다. 유저는 쿠버네티스를 통해 운용되는 서비스에 접속할 때 이 로드 밸런서를 통하게 되며, 클래스터 내 각 호스트의 어떤 컨테이너가 목적지인지를 안내합니다.


### 1.2.1 오퍼레이션 자동화

쿠버네티스에게 전달하는 명령어의 집합(docker compose와 유사)인 디플로이먼트에는 컨테이너로 하여금 유지되기를 희망하는 *상태* 를 정의합니다. 가령 정의된 CPU 사용량, 메모리 사용량 등을 기반으로 파드는 레플리카의 수를 자동으로 제어할 수 있습니다. 최소 운영 레플리카를 3개로 두었다가 일정 기준 이상이 넘으면 5개, 7개 등으로 확장이 가능한 것입니다.

### 1.2.2 확장성(scalability) 제고

시중에는 서비스를 디플로이 할 수 있는 수많은 서비스가 공개되어 있습니다. Heroku, AWS Elastic Beanstalk 과 같이 PaaS(Platform as a Service) 형태의 서비스에는 개발한 소스코드와 설정(config) 파일만 같이 올리면 모든 것을 알아서 처리해줍니다. MVP(Minimum Viable Product, 최소 기능 제품)를 구축하거나 스토리지 용량이 크지 않은 경우, 24시간 작동하지 않아도 비즈니스에 큰 해를 끼치지 않는 경우라면 위와 같은 형태의 서비스를 활용하는 것도 좋은 선택지 중 하나입니다. 하지만, 지속적으로 유저가 증가하고 비즈니스 로직이 복잡해진다면 PaaS 에서 지원하는 범위를 초과하게 됩니다. 다른 서비스로 갑작스럽게 마이그레이션을 준비해야 하는 난처한 상황이 발생할 수 있는 것이죠.

서비스를 설계할 당시 대량의 유저를 타겟으로 하거나 서비스의 규모가 점진적으로 확대되는 모델인 경우 확장성을 고려해야 합니다. 이는 MCU(Maximum Current Users, 최대 동시 접속 사용자) 및 DAU(Daily Active Users, 일일 활성 사용자) 등의 지표를 통해 사전에 설계할 수 있습니다.  

쿠버네티스는 확장에 대한 고민을 덜 수 있도록 서비스의 규모와 상관 없이 수많은 컨테이너를 스케쥴링하고 job(잡)을 부여할 수 있도록 설계되어 있습니다. 구글은 매주 수십억 개의 컨테이너를 생성한다고 하죠. 확장성이 좋다는 표현을 더 구체적으로 설명하면 **여러 호스트로 이루어진 클러스터에 필요한 만큼 컨테이너를 생성하고 이를 설정한 규칙에 따라 운용할 수 있다고** 할 수 있습니다.


