### 1. 쿠버네티스의 설계 사상
- `선언적 구성`  : "내 웹서비스의 레플리카를 항상 5개씩 실행하고 싶습니다 < - > 명령어 구성 : 레플리카를 5개 만들어
   - 제어 루프 : 현재 상태를 관찰하여 사용자가 원하는 상태로 유지
   - 즉, 명령어로 구성하면 `실패할 땐` 또 명령어로 실행해야한다
   - 그러나 여기서 말하고자 하는 것은 매 번 명령어로 수행할 필요없이 현재 상태를 계속 관찰하며 요구 내용에 맞추도록 조정
   - ex) 난 a노드에 파드 5개 유지하고싶어. -> 만약 5개 중 2개가 죽으면 알아서 2개를 만들어 채운다

- `컨트롤러 구성` : 각 기능별로 독립적으로 분산되게 설계 => 유연하고 안정적이지만 복잡
- `동적 그룹화` : 우리 팀원은 오렌지 색 옷을 입은 사람들입니다 or 애플리케이션이 `백엔드`인 것들만 < - > 정적 그룹화 : 우리 팀원은 남기석 남기석2
   - 구체화보다 추상적으로. 역할과 담당자를 구분 / 언제든지 대체 가능
   - 레이블(쿼리 가능) 및 어노테이션(메타데이터용)으로 구성

- `API 기반 상호작용` : 쿠버네티스 요소들이 서로 직접 접근불가. 구성 요소를 대체하기 용이
  - 구성 요소원에게 의존x  / API에 기반하여 이 API를 담당하는 구성 요소는 언제든지 바뀌어도 대처가능한 유연함 
![화면 캡처 2021-10-13 204005](https://user-images.githubusercontent.com/62214428/137125859-17f2b672-d51c-48fa-9118-37ab8f1a7467.png)


### 2. 쿠버네티스의 구조 : 클러스터
- `클러스터`란? : `노드`라고 하는 `워커 머신`의 집합
- `노드`란? : 컨테이너화 된 애플리케이션을 실행하는 서버  / 하나의 노드에 여러 컨테이너화 된 애플리케이션 ( `파드` ) 존재가능
- `워커 노드`란? : 애플리케이션의 구성요소인 파드( > 컨테이너 )를 호스트
- `컨트롤 플레인`이란? : == `마스터 노드`로 워커 노드와 클러스터의 파드들을 관리

![화면 캡처 2021-10-13 204415](https://user-images.githubusercontent.com/62214428/137126654-e427652f-cc29-4d5a-99b7-9ee5e144d745.png)


### 3. 쿠버네티스의 구조 : 클러스터 구성요소 ( 마스터노드 )
![화면 캡처 2021-10-13 205001](https://user-images.githubusercontent.com/62214428/137127162-187b997a-dd8f-48fc-930f-bca1d6f27440.png)
- `API서버` : 즉 외부에서 접근할 수 있도록 api노출 / 외부에선 이 api들을 통해서 접근
- `etcd` : 쿠버네티스에 관련된 모든 내용이 etcd에 저장 / 쿠버네티스에 지금 파드가 몇개인지~ , a파드가 어떤 노드에 존재하는지~ ..
- `스케쥴러` 
- `컨트롤러 매니저` : ex) 난 a노드에 파드 5개 유지하고싶어. -> 만약 5개 중 2개가 죽으면 알아서 2개를 만들어 채운다
