![image](https://user-images.githubusercontent.com/62214428/146668478-2dafefa7-5be6-4cdf-9b6b-cec3c7b3b7c0.png)

- 웹/사이드카 컨테이너 선정의 이유 및 구축 과정에 대한 가이드라인을 상세하게 작성
- 웹/사이드카 컨테이너는 과제 수행에 적당한 것으로 자유 선택 가능
- 웹 로그를 저장하는 엘라스틱서치는 데이터가 계속 보존될 수 있도록 해결책을 제시하고, 엘라스틱서치가 새로운 버전으로 업데이트 되어도 데이터가 보존될 수 있도록 처리하는 실습이 반드시 포함되어야 함


### 계획
- ( nginx웹서버 & 파일비트 사이드카) 컨테이너 구성
  - nginx웹 서버에 접속할 때 access.log를 filebeat가 긁어모아 이를 elasticsearch에 전달하고 저장
- 엘라스틱서치와 키바나(추가적으로 해보기) 각각 구성 
- 엘라스틱 서치는 별도의 볼륨을 잡아 데이터를 보존
  - hostpath를 통해 해당 볼륨을 노드와 공유함으로써 컨테이너가 삭제되거나 업데이트해도 노드에 저장되어 있는 정보를 다시 끌어올 수 있도록


### 과정
#### 0. filebeat configmap작성
- configmap을 작성하지 않고 진행했을 때 filebeat.yml가 readonly여서 수정 x 
- 권한을 바꾸기보다 configmap 예제를 활용해보기
```
apiVersion: v1
kind: ConfigMap
metadata:
  name: filebeat-configmap
data:
  filebeat.yml: |
    filebeat:
      config:
        modules:
          path: /usr/share/filebeat/modules.d/*.yml
          reload:
            enabled: true
      modules:
      - module: nginx
        access:
          var.paths: ["/var/log/nginx/access.log*"]
        error:
          var.paths: ["/var/log/nginx/error.log*"]
    output:
      elasticsearch:
        hosts: ["elasticsearch:9200"] 
```
- hosts 수정 필요
#### 1. nginx웹서버와 파일비트 사이드카 컨테이너 구성하기
- 참고로 이미지 이름 제대로 확인하고 적어라 안그러면 pullbackoff
- ![image](https://user-images.githubusercontent.com/62214428/146684646-c1d68b6e-0748-4e85-aa46-cc72ab6c88fb.png)
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-deployment
  labels:
    app: hello-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hello-pod
  template:
    metadata:
      name: hello-pod
      labels:
        app: hello-pod
    spec:
      containers:
        - name: hello-world
          image: nginxdemos/hello
          ports:
            - containerPort: 80
          volumeMounts:
            - name: nginx-logs
              mountPath: var/log/nginx/
        - name: filebeat-sidecar
          image: docker.elastic.co/beats/filebeat:7.14.1
          volumeMounts:
            - name: nginx-logs
              mountPath: var/log/nginx/
            - name: filebeat-config
              mountPath: /usr/share/filebeat/filebeat.yml
              subPath: filebeat.yml 
      volumes:
        - name: nginx-logs
        - name: filebeat-config
          configMap:
            name: filebeat-configmap
            items:
              - key: filebeat.yml
                path: filebeat.yml

```
#### 2. nginx 접근위해 expose & filebeat 설정
- filebeat 설정
  - configmap을 활용하여 설정
  - `kubectl exec -it <deployment이름> -c <컨테이너명=filebeat-sidecar> -- /bin/sh`
  - ![image](https://user-images.githubusercontent.com/62214428/146682427-5030b346-c32e-45da-8da2-36781abccfe9.png)
  - ![image](https://user-images.githubusercontent.com/62214428/146682449-4e381b42-1dce-49bf-844c-e11806f67f7d.png)

- service
```
kubectl expose deployment hello-deployment --type=NodePort --port=80 --target-port=80
```
![image](https://user-images.githubusercontent.com/62214428/146676937-3ce4516b-681c-40f7-a371-f48c79200451.png)
![image](https://user-images.githubusercontent.com/62214428/146676939-bd11dedf-69c7-4c5f-968c-57b39e59dbae.png)


#### 3. elasticsearch 컨테이너 구성
- 해당 컨테이너가 종료되어도 정보를 유지하기 위해 볼륨을 잡아줬다
- 이를 노드와 연결하기위해 hostpath
- 이제 노드1번의 /data와 elastic 컨테이너의 /test-volume이 
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: elasticsearch
  labels:
    app: elasticsearch
spec:
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
      containers:
      - name: elasticsearch
        image: elastic/elasticsearch:7.14.1
        env:
        - name: discovery.type
          value: "single-node"
        ports:
        - containerPort: 9200
        - containerPort: 9300
        volumeMounts:
        - mountPath: /test-pd
          name: test-volume
      volumes:
      - name: test-volume
        hostPath:
          path: /data
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: elasticsearch
  name: elasticsearch-svc
  namespace: default
spec:
  ports:
  - name: elasticsearch-rest
    nodePort: 30920
    port: 9200
    protocol: TCP
    targetPort: 9200
  - name: elasticsearch-nodecom
    nodePort: 30930
    port: 9300
    protocol: TCP
    targetPort: 9300  
  selector:
    app: elasticsearch
  type: NodePort
```
- ![image](https://user-images.githubusercontent.com/62214428/146682949-1b48e473-4cd7-4fbd-be1f-8c75eff72f60.png)
- ![image](https://user-images.githubusercontent.com/62214428/146682936-dca9308b-1032-4112-818f-5f29f08acdb2.png)

#### 4. kibana 컨테이너 구성해보기 추가.
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kibana
  labels:
    app: kibana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kibana
  template:
    metadata:
      labels:
        app: kibana
    spec:
      containers:
      - name: kibana
        image: elastic/kibana:7.14.1
        env:
        - name: SERVER_NAME
          value: "kibana.kubenetes.example.com"
        - name: ELASTICSEARCH_URL
          value: "http://elasticsearch-svc.default.svc.cluster.local:9200"
        ports:
        - containerPort: 5601
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: kibana
  name: kibana-svc
  namespace: default
spec:
  ports:
  - nodePort: 30561
    port: 5601
    protocol: TCP
    targetPort: 5601
  selector:
    app: kibana
  type: NodePort

```






